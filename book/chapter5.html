


<div id="way-contingency-tables-with-tabyl" class="section level2">
<h2>3-way contingency tables with tabyl</h2>
<p>Use the <code>tabyl()</code> function from the <code>janitor</code>
package. With several adorning functions you can adjust the table to
your liking. You can force the table displaying the values ‘none’,
‘some’ and ‘many’ in the correct order, by making sure the variable is
stored as an ‘ordered factor’ (see chapter 2).</p>
<pre class="r"><code>library(janitor)

mtcars %&gt;% 
  tabyl(am, gear, cyl, show_na = FALSE) %&gt;% 
  adorn_title(&quot;combined&quot;) %&gt;% #both var names in the title
  adorn_totals(&quot;col&quot;) %&gt;% #column totals
  adorn_totals(&quot;row&quot;) %&gt;% #row totals
  adorn_percentages(&quot;col&quot;) %&gt;% #columnwise, rowwise (row), or total percentages (all)
  adorn_pct_formatting(digits = 1) %&gt;%
  adorn_ns() #show the numbers of cases</code></pre>
</div>
<div id="groups-in-a-scatterplot" class="section level2">
<h2>Groups in a scatterplot</h2>
<p>If you want to visualize different groups in the scatterplot, you can
add extra variables to the aesthetics of a ggplot. In addition to x and
y, you can use color (the “outside” color of points), fill (the “inside”
color of the points), shape (of the points) and size.</p>
<pre class="r"><code>mtcars %&gt;% 
  ggplot(aes(x = cyl, 
             y = mpg, 
             color = factor(gear)
             )
         ) + 
  geom_point()</code></pre>
</div>
<div id="faceting-of-bivariate-visualisations" class="section level2">
<h2>Faceting of bivariate visualisations</h2>
<p>For different subplots, use the layer <code>facet_wrap(~ )</code> as
default. This is another way to introduce a third variable in the
context of data visualizations.</p>
<pre class="r"><code>mpg %&gt;% 
  ggplot(aes(x = factor(cyl), y = hwy)) +
  geom_boxplot() + 
  facet_wrap(~ year)</code></pre>
</div>
<div id="linear-models" class="section level2">
<h2>Linear models</h2>
<p>For the ordinary linear model, we use <code>lm()</code>. For a clear
presentation of the regression table, we use the <code>tidy()</code>
function from the <code>broom</code> package.</p>
<pre class="r"><code>library(broom)

model &lt;- mtcars %&gt;% 
  lm(qsec ~ wt + cyl, data = .) 

# the regression table  
model %&gt;% 
  tidy()

# the ANOVA table
model %&gt;% 
  anova() %&gt;% 
  tidy()

# overall output, including R squared, is provided by
model %&gt;% 
  summary()</code></pre>
</div>
<div id="diagnostics-residuals-equal-variances-outliers-and-influence" class="section level2">
<h2>Diagnostics: residuals, equal variances, outliers and influence</h2>
<p>There are various ways to create plots with the residuals and/or the
predicted values.</p>
<pre class="r"><code># always create a model you want to diagnose first

model &lt;- mtcars %&gt;% 
  lm(qsec ~ wt + cyl, data = .) 

# the object &#39;model&#39; now contains the residuals and the predicted values.
# residuals and predicted values can  be added to the data frame in two ways:

# directly
mtcars$residuals &lt;- model$residuals
mtcars$predictions &lt;- model$fitted.values

# or by using the modelr package:
library(modelr)
mtcars &lt;- mtcars %&gt;% 
  add_predictions(model) %&gt;% 
  add_residuals(model)

# after adding the residuals and the predicted values displaying residuals plots is done in a ggplot
mtcars %&gt;% 
  ggplot(aes(x = pred, y = resid)) + 
  geom_point()</code></pre>
<p>There are various ways to test for unequal variances in a model.
These are available in various packages, including <code>car</code> and
in <code>lmtest</code>. Levene’s test is introduced in chapter 4.</p>
<pre class="r"><code># Breusch-Pagan Test
library(lmtest)

# estimate the model first and then:
bptest(model)</code></pre>
<p>For outliers and influential cases, use:</p>
<pre class="r"><code># After estimating and storing a model, leverage as measured by the hat values can be stored to the original data frame, by using
data$leverage_cases_model_1 &lt;- hatvalues(model_1)

# Also, one of the plots of the model contains info about Cook&#39;s distances
plot(model_1)

# After estimating and storing the model, influence as measured by cooks distances can be stored to the original data frame, by using
data$influential_cases_model_1 &lt;- cooks.distance(model_1)

# Also, one of the plots of the model contains info about Cook&#39;s distances
plot(model_1)</code></pre>
<p>After estimating the model, detecting multicollinearity can be done
using the <code>car</code> library.</p>
<pre class="r"><code>library(car)
vif(model)</code></pre>
</div>
<div id="linear-mixed-models" class="section level2">
<h2>linear mixed models</h2>
<p>For the linear mixed model, we use the <code>lmer()</code> function
from the <code>lme4</code> package. Note that the output does not show
<em>p</em>-values, nor residual degrees of freedom for fixed effects.
This is for a good <a href="https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html">reason</a>.</p>
<pre class="r"><code>library(lme4)

mtcars %&gt;% 
  lmer(qsec ~ wt + (1|gear), data = .) %&gt;% 
  tidy()

# When we have factors as fixed variables:
mtcars %&gt;% 
  lmer(qsec ~ wt + factor(cyl) + (1|gear), data = .) %&gt;% 
  anova() %&gt;% 
  tidy()</code></pre>
<p>If you want approximate <em>p</em>-values, you can use
Satterthwaite’s degrees of freedom method, implemented in the
<code>lmerTest</code> package. The same method is used in SPSS.</p>
<pre class="r"><code>library(lmerTest)
mtcars %&gt;% 
  lmer(qsec ~ wt + (1|gear), data = .) %&gt;% 
  summary()</code></pre>
<p>For a residual plot, we can use similar syntax as for the linear
model, using <code>modelr</code>:</p>
<pre class="r"><code>model &lt;- mtcars %&gt;% 
  lmer(qsec ~ wt + (1|gear), data = .)  

mtcars %&gt;% 
  add_predictions(model) %&gt;% 
  add_residuals(model) %&gt;% 
  ggplot(aes(x = pred, y = resid)) +
  geom_point()</code></pre>
</div>
<div id="logistic-regression" class="section level2">
<h2>logistic regression</h2>
<p>For a logistic regression model, we use the <code>glm()</code>
function.</p>
<pre class="r"><code>mtcars %&gt;% 
  glm(am ~ wt, family = binomial, data = .) %&gt;% 
  tidy()</code></pre>
<p>Similarly for a Poisson regression.</p>
<pre class="r"><code>mtcars %&gt;% 
  glm(carb ~ wt, family = poisson, data = .) %&gt;% 
  tidy()</code></pre>
</div>
<div id="nonparametric-tests-for-repeated-measures" class="section level2">
<h2>Nonparametric tests for repeated measures</h2>
<p>For a non-parametric test for repeated measures, we use</p>
<pre class="r"><code>iris %&gt;% 
  select(Sepal.Length, Petal.Length) %&gt;% 
  as.matrix() %&gt;%
  friedman.test()</code></pre>
</div>
